package com.dominikgruber.scalatorrent.tracker

import java.nio.ByteBuffer

import com.dominikgruber.scalatorrent.tracker
import com.dominikgruber.scalatorrent.util.ByteUtil.bytes

import scala.util.Try

/**
  * official doc: http://www.bittorrent.org/beps/bep_0015.html
  * libtorrent: http://www.rasterbar.com/products/libtorrent/udp_tracker_protocol.html#scraping
  */
object UDPMessages {

  sealed trait Message
  sealed trait Request extends Message
  sealed trait Response extends Message

  /**
    * Random value chosen by the requester
    */
  case class TransactionId(value: Int)
  case class ConnectionId(value: Long)

  /**
    * Obtain a [[ConnectionId]] so we can follow with an useful request
    */
  case class ConnectRequest(trans: TransactionId) extends Request
  case class ConnectResponse(trans: TransactionId, conn: ConnectionId) extends Response

  /**
    * 20-byte info hash identifying a torrent.
    * Generated by SHA-1 hash on a part of the torrent file (bencode format) describing the torrent's content.
    */
  case class InfoHash(value: Array[Byte])

  /**
    * 20-byte
    */
  case class PeerId(value: Array[Byte])

  trait AnnounceEvent{ val code: Int }
  case object None extends AnnounceEvent{ val code = 0 }
  case object Completed extends AnnounceEvent{ val code = 1 }
  case object Started extends AnnounceEvent{ val code = 2 }
  case object Stopped extends AnnounceEvent{ val code = 3 }

  /**
    * Announce this peer to the tracker. Get addresses of other peers in return.
    * @param ip 0 means use the source ip in this package
    * @param key random id chosen by us (this peer) so the tracker can identify us if our ip has changed
    * @param numWant how many peer addresses we'd like to receive (-1 means default, which is usually 50)
    * @param port we're listening to. 16-bit
    */
  case class AnnounceRequest(conn: ConnectionId, trans: TransactionId, torrentHash: InfoHash, peerId: PeerId,
                             downloaded: Long, left: Long, uploaded: Long, event: AnnounceEvent, ip: Long = 0,
                             key: Long, numWant: Int = -1, port: Int) extends Request
  case class AnnounceResponse(trans: TransactionId, interval: Int, leechers: Int, seeders: Int, peers: Seq[PeerAddress]) extends Response

//  case class ScrapeReport(seeders: Int, completed: Int, leechers: Int)
//  case class ScrapeRequest(conn: ConnectionId, trans: TransactionId, hashes: Seq[InfoHash]) extends Request
//  case class ScrapeResponse(trans: TransactionId, reports: Seq[ScrapeReport]) extends Response

  case class Error(trans: TransactionId, message: String) extends Response

  def encode(req: Request): Array[Byte] = req match {
    case c: ConnectRequest => Connect.encode(c)
    case a: AnnounceRequest => Announce.encode(a)
  }

  def decode(bytes: Array[Byte]): Try[Response] = {
    Try { Connect.decode(bytes) } orElse
      Try { Announce.decode(bytes) }
  }

  object Connect {
    val action = 0
    def encode(req: ConnectRequest): Array[Byte] = {
      val bb = ByteBuffer.allocate(16)
      bb.putLong(0x0000041727101980L) //protocol id
      bb.putInt(action)
      bb.putInt(req.trans.value)
      bb.array()
    }
    def decode(rep: Array[Byte]): ConnectResponse = {
      val action = rep.getInt(0)
      require(action == Connect.action)
      val trans = rep.getInt(4)
      val conn = rep.getLong(8)
      ConnectResponse(TransactionId(trans), ConnectionId(conn))
    }
  }

  object Announce {
    val action = 1
    def encode(req: AnnounceRequest): Array[Byte] = {
      val bb = ByteBuffer.allocate(98)
      bb.putLong(req.conn.value)
      bb.putInt(action)
      bb.putInt(req.trans.value)
      bb.put(req.torrentHash.value)
      bb.put(req.peerId.value)
      bb.putLong(req.downloaded)
      bb.putLong(req.left)
      bb.putLong(req.uploaded)
      bb.putInt(req.event.code)
      bb.putInt(req.ip.toInt)
      bb.putInt(req.key.toInt)
      bb.putInt(req.numWant)
      bb.putShort(req.port.toShort)
      bb.array()
    }
    def decode(rep: Array[Byte]): AnnounceResponse = {
      val action = rep.getInt(0)
      require(action == Announce.action)
      val trans = TransactionId(rep.getInt(4))
      val interval = rep.getInt(8)
      val leechers = rep.getInt(12)
      val seeders = rep.getInt(16)
      val peers: List[PeerAddress] = rep.drop(20).grouped(6).map { PeerAddress.decode }.toList
      AnnounceResponse(trans, interval, leechers, seeders, peers)
    }
  }

  object Error {
    val action = 3
  }

  object PeerAddress {
    def decode(rep: Array[Byte]): PeerAddress = {
      val host = ipAsString(rep.getInt(0))
      val port = rep.getUnsignedShort(4)
      tracker.PeerAddress(host, port)
    }
  }

  implicit class BytesOps(bytess: Array[Byte]) {
    def getShort(from: Int): Short = ByteBuffer.wrap(bytess.drop(from).take(2)).getShort
    def getInt(from: Int): Int = ByteBuffer.wrap(bytess.drop(from).take(4)).getInt
    def getLong(from: Int): Long = ByteBuffer.wrap(bytess.drop(from).take(8)).getLong
    def getUnsignedShort(from: Int): Int = {
      val paddedBytes = bytes("00 00") ++ bytess.drop(from).take(2)
      ByteBuffer.wrap(paddedBytes).getInt
    }
    def getUnsignedByte(from: Int): Short = {
      val paddedBytes = bytes("00") ++ bytess.drop(from).take(1)
      ByteBuffer.wrap(paddedBytes).getShort
    }
  }
  def ipAsString(ip: Int): String =
    ByteBuffer.allocate(4).putInt(ip).array()
      .map{ Array(_).getUnsignedByte(0) }
      .mkString(".")

}
