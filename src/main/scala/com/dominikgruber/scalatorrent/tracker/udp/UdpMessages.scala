package com.dominikgruber.scalatorrent.tracker.udp

import com.dominikgruber.scalatorrent.tracker.PeerAddress
import com.dominikgruber.scalatorrent.tracker.udp.UdpMessages.Bytes20
import shapeless._

/**
  * official doc: http://www.bittorrent.org/beps/bep_0015.html
  * libtorrent: http://www.rasterbar.com/products/libtorrent/udp_tracker_protocol.html#scraping
  */
object UdpMessages {
  type Bytes20 = Sized[Array[Byte], Nat._20]
}

sealed trait Message
sealed trait Request extends Message
sealed trait Response extends Message

/**
  * Obtain a [[ConnectionId]] so we can follow with an useful request
  */
case class ConnectRequest(trans: TransactionId) extends Request
case class ConnectResponse(trans: TransactionId, conn: ConnectionId) extends Response

trait AnnounceEvent{ val code: Int }
object AnnounceEvent {
  case object None extends AnnounceEvent{ val code = 0 }
  case object Completed extends AnnounceEvent{ val code = 1 }
  case object Started extends AnnounceEvent{ val code = 2 }
  case object Stopped extends AnnounceEvent{ val code = 3 }
}

/**
  * Announce this peer to the tracker. Get addresses of other peers in return.
  * @param ip 0 means use the source ip in this package
  * @param key random id chosen by us (this peer) so the tracker can identify us if our ip has changed
  * @param numWant how many peer addresses we'd like to receive (-1 means default, which is usually 50)
  * @param port we're listening to. 16-bit
  */
case class AnnounceRequest(conn: ConnectionId, trans: TransactionId, torrentHash: InfoHash, peerId: PeerId,
                           downloaded: Long, left: Long, uploaded: Long, event: AnnounceEvent, ip: Long = 0,
                           key: Long, numWant: Int = -1, port: Int) extends Request
case class AnnounceResponse(trans: TransactionId, interval: Int, leechers: Int, seeders: Int,
                            peers: Seq[PeerAddress]) extends Response

case class Error(trans: TransactionId, message: String) extends Response

/**
  * Random value chosen by the requester
  */
case class TransactionId(value: Int)
case class ConnectionId(value: Long)

/**
  * 20-byte info hash identifying a torrent.
  * Generated by SHA-1 hash on a part of the torrent file (bencode format) describing the torrent's content.
  */
case class InfoHash(value: Bytes20)
object InfoHash {
  def validate(bytes: Array[Byte]): InfoHash = {
    require(bytes.length == 20)
    InfoHash(Sized.wrap(bytes))
  }
}

/**
  * 20-byte
  */
case class PeerId(value: Bytes20)
object PeerId {
  def validate(bytes: Array[Byte]): PeerId = {
    require(bytes.length == 20)
    PeerId(Sized.wrap(bytes))
  }
}
